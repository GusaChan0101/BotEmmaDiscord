const sqlite3 = require('sqlite3').verbose();
const fs = require('fs');

console.log('üîß Iniciando corre√ß√£o do banco de dados...\n');

// Conectar ao banco
const db = new sqlite3.Database('./database.db', (err) => {
    if (err) {
        console.error('‚ùå Erro ao conectar ao banco:', err.message);
        process.exit(1);
    }
    console.log('‚úÖ Conectado ao banco de dados\n');
});

// Fun√ß√£o para verificar se uma coluna existe
function checkColumnExists(tableName, columnName) {
    return new Promise((resolve) => {
        db.all(`PRAGMA table_info(${tableName})`, (err, columns) => {
            if (err) {
                resolve(false);
                return;
            }
            const exists = columns.some(col => col.name === columnName);
            resolve(exists);
        });
    });
}

// Fun√ß√£o para verificar se uma tabela existe
function checkTableExists(tableName) {
    return new Promise((resolve) => {
        db.get(`SELECT name FROM sqlite_master WHERE type='table' AND name=?`, [tableName], (err, row) => {
            resolve(!!row);
        });
    });
}

// Fun√ß√£o principal de migra√ß√£o
async function migrateDatabase() {
    console.log('üìã Verificando estrutura das tabelas...\n');
    
    try {
        // 1. Verificar tabela voice_time
        const voiceTableExists = await checkTableExists('voice_time');
        
        if (!voiceTableExists) {
            console.log('üìù Criando tabela voice_time...');
            await runQuery(`CREATE TABLE voice_time (
                user_id TEXT,
                guild_id TEXT,
                total_time INTEGER DEFAULT 0,
                session_start INTEGER,
                sessions INTEGER DEFAULT 0,
                created_at INTEGER DEFAULT (strftime('%s', 'now')),
                PRIMARY KEY (user_id, guild_id)
            )`);
            console.log('‚úÖ Tabela voice_time criada\n');
        } else {
            console.log('üîç Verificando colunas da tabela voice_time...');
            
            // Verificar colunas necess√°rias
            const hasSessionStart = await checkColumnExists('voice_time', 'session_start');
            const hasSessions = await checkColumnExists('voice_time', 'sessions');
            const hasCreatedAt = await checkColumnExists('voice_time', 'created_at');
            
            // Adicionar colunas em falta
            if (!hasSessionStart) {
                console.log('‚ûï Adicionando coluna session_start...');
                await runQuery(`ALTER TABLE voice_time ADD COLUMN session_start INTEGER`);
                console.log('‚úÖ Coluna session_start adicionada');
            }
            
            if (!hasSessions) {
                console.log('‚ûï Adicionando coluna sessions...');
                await runQuery(`ALTER TABLE voice_time ADD COLUMN sessions INTEGER DEFAULT 0`);
                console.log('‚úÖ Coluna sessions adicionada');
            }
            
            if (!hasCreatedAt) {
                console.log('‚ûï Adicionando coluna created_at...');
                await runQuery(`ALTER TABLE voice_time ADD COLUMN created_at INTEGER DEFAULT (strftime('%s', 'now'))`);
                console.log('‚úÖ Coluna created_at adicionada');
            }
            
            // Atualizar sessions para registros existentes que tenham 0
            await runQuery(`UPDATE voice_time SET sessions = 1 WHERE sessions = 0 AND total_time > 0`);
            console.log('‚úÖ Tabela voice_time atualizada\n');
        }
        
        // 2. Verificar e criar outras tabelas importantes
        await createTableIfNotExists('guild_settings', `CREATE TABLE IF NOT EXISTS guild_settings (
            guild_id TEXT PRIMARY KEY,
            log_channel_id TEXT,
            ticket_category_id TEXT,
            vip_category_id TEXT,
            welcome_channel_id TEXT,
            auto_role_id TEXT,
            mute_role_id TEXT,
            mod_log_channel_id TEXT,
            support_role_id TEXT,
            council_role_id TEXT,
            created_at INTEGER DEFAULT (strftime('%s', 'now')),
            updated_at INTEGER DEFAULT (strftime('%s', 'now'))
        )`);
        
        await createTableIfNotExists('tickets', `CREATE TABLE IF NOT EXISTS tickets (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ticket_id TEXT UNIQUE,
            channel_id TEXT UNIQUE,
            user_id TEXT,
            guild_id TEXT,
            type TEXT DEFAULT 'support',
            status TEXT DEFAULT 'open' CHECK(status IN ('open', 'closed', 'archived')),
            priority TEXT DEFAULT 'normal' CHECK(priority IN ('low', 'normal', 'high', 'urgent')),
            assigned_to TEXT,
            created_at INTEGER DEFAULT (strftime('%s', 'now')),
            closed_at INTEGER,
            closed_by TEXT,
            close_reason TEXT
        )`);
        
        await createTableIfNotExists('vips', `CREATE TABLE IF NOT EXISTS vips (
            user_id TEXT,
            guild_id TEXT,
            vip_type TEXT CHECK(vip_type IN ('bronze', 'prata', 'ouro', 'diamante')),
            expires_at INTEGER,
            created_at INTEGER DEFAULT (strftime('%s', 'now')),
            created_by TEXT,
            PRIMARY KEY (user_id, guild_id)
        )`);
        
        await createTableIfNotExists('message_count', `CREATE TABLE IF NOT EXISTS message_count (
            user_id TEXT,
            guild_id TEXT,
            count INTEGER DEFAULT 0,
            last_message INTEGER DEFAULT (strftime('%s', 'now')),
            daily_count INTEGER DEFAULT 0,
            last_daily_reset INTEGER DEFAULT (strftime('%s', 'now')),
            PRIMARY KEY (user_id, guild_id)
        )`);
        
        await createTableIfNotExists('user_levels', `CREATE TABLE IF NOT EXISTS user_levels (
            user_id TEXT,
            guild_id TEXT,
            xp INTEGER DEFAULT 0,
            level INTEGER DEFAULT 0,
            messages INTEGER DEFAULT 0,
            voice_time INTEGER DEFAULT 0,
            last_xp_gain INTEGER DEFAULT 0,
            PRIMARY KEY (user_id, guild_id)
        )`);
        
        await createTableIfNotExists('verifications', `CREATE TABLE IF NOT EXISTS verifications (
            user_id TEXT,
            guild_id TEXT,
            verification_code TEXT,
            verified_at INTEGER DEFAULT (strftime('%s', 'now')),
            verified_by TEXT,
            verification_method TEXT DEFAULT 'manual',
            PRIMARY KEY (user_id, guild_id)
        )`);
        
        await createTableIfNotExists('warnings', `CREATE TABLE IF NOT EXISTS warnings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT,
            guild_id TEXT,
            reason TEXT,
            evidence TEXT,
            warned_by TEXT,
            severity TEXT DEFAULT 'low' CHECK(severity IN ('low', 'medium', 'high')),
            active BOOLEAN DEFAULT 1,
            created_at INTEGER DEFAULT (strftime('%s', 'now')),
            expires_at INTEGER
        )`);
        
        // 3. Limpar dados √≥rf√£os antigos se houver
        console.log('üßπ Limpando dados √≥rf√£os...');
        await runQuery(`UPDATE voice_time SET session_start = NULL WHERE session_start IS NOT NULL`);
        console.log('‚úÖ Dados √≥rf√£os limpos\n');
        
        // 4. Verificar integridade do banco
        console.log('üîç Verificando integridade do banco...');
        const integrity = await runQuery(`PRAGMA integrity_check`);
        console.log('‚úÖ Verifica√ß√£o de integridade conclu√≠da\n');
        
        console.log('üéâ MIGRA√á√ÉO CONCLU√çDA COM SUCESSO!\n');
        console.log('üìä Resumo das corre√ß√µes:');
        console.log('‚úÖ Tabela voice_time corrigida com session_start');
        console.log('‚úÖ Todas as tabelas necess√°rias criadas');
        console.log('‚úÖ Dados √≥rf√£os limpos');
        console.log('‚úÖ Banco de dados pronto para uso\n');
        console.log('üöÄ Agora voc√™ pode iniciar o bot com: npm start');
        
    } catch (error) {
        console.error('‚ùå Erro durante a migra√ß√£o:', error.message);
        console.log('\nüîß Tentando solu√ß√£o alternativa...\n');
        
        // Solu√ß√£o alternativa: recriar tabela voice_time
        try {
            console.log('üíæ Fazendo backup dos dados existentes...');
            const backupData = await runQuery(`SELECT * FROM voice_time`);
            
            console.log('üóëÔ∏è Removendo tabela antiga...');
            await runQuery(`DROP TABLE IF EXISTS voice_time`);
            
            console.log('üÜï Criando nova tabela...');
            await runQuery(`CREATE TABLE voice_time (
                user_id TEXT,
                guild_id TEXT,
                total_time INTEGER DEFAULT 0,
                session_start INTEGER,
                sessions INTEGER DEFAULT 0,
                created_at INTEGER DEFAULT (strftime('%s', 'now')),
                PRIMARY KEY (user_id, guild_id)
            )`);
            
            console.log('üì• Restaurando dados...');
            if (Array.isArray(backupData) && backupData.length > 0) {
                for (const row of backupData) {
                    await runQuery(`INSERT OR REPLACE INTO voice_time (user_id, guild_id, total_time, sessions) VALUES (?, ?, ?, ?)`,
                        [row.user_id, row.guild_id, row.total_time || 0, row.sessions || 1]);
                }
                console.log(`‚úÖ ${backupData.length} registros restaurados`);
            }
            
            console.log('üéâ CORRE√á√ÉO ALTERNATIVA CONCLU√çDA!\n');
            console.log('üöÄ Agora voc√™ pode iniciar o bot com: npm start');
            
        } catch (altError) {
            console.error('‚ùå Erro na solu√ß√£o alternativa:', altError.message);
            console.log('\nüí° SOLU√á√ÉO MANUAL:');
            console.log('1. Pare o bot se estiver rodando');
            console.log('2. Delete o arquivo database.db');
            console.log('3. Execute: npm start');
            console.log('4. O bot criar√° um novo banco com a estrutura correta');
            console.log('\n‚ö†Ô∏è NOTA: Voc√™ perder√° os dados salvos, mas o bot funcionar√° perfeitamente');
        }
    } finally {
        db.close((err) => {
            if (err) {
                console.error('Erro ao fechar banco:', err.message);
            } else {
                console.log('üîê Banco fechado com seguran√ßa');
            }
            process.exit(0);
        });
    }
}

// Fun√ß√£o auxiliar para executar queries
function runQuery(sql, params = []) {
    return new Promise((resolve, reject) => {
        if (sql.trim().toLowerCase().startsWith('select') || sql.trim().toLowerCase().startsWith('pragma')) {
            db.all(sql, params, (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        } else {
            db.run(sql, params, function(err) {
                if (err) reject(err);
                else resolve(this);
            });
        }
    });
}

// Fun√ß√£o auxiliar para criar tabela se n√£o existir
async function createTableIfNotExists(tableName, createSQL) {
    const exists = await checkTableExists(tableName);
    if (!exists) {
        console.log(`üìù Criando tabela ${tableName}...`);
        await runQuery(createSQL);
        console.log(`‚úÖ Tabela ${tableName} criada`);
    } else {
        console.log(`‚úÖ Tabela ${tableName} j√° existe`);
    }
}

// Executar migra√ß√£o
migrateDatabase();